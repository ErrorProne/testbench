---
title: Special Testing Topics
order: 3
layout: page
---

[[testbench.special.waitforvaadin]]
== Waiting for Vaadin

Traditional web pages load a page that is immediately rendered by the browser.
In such applications, you can test the page elements immediately after the page
is loaded. In Vaadin and other SPAs (Single Page Applications), rendering is done by
JavaScript code asynchronously, so you need to wait until the server has given
its response to an AJAX request and the JavaScript code finishes rendering the
UI. A major advantage of using TestBench compared to other testing solutions is that 
TestBench knows when something is still being rendered on the page and automatically
waits for that rendering to finish before moving on with the test.


In most cases, this is not something you need to take into account as waiting is automatically enabled. It might be necessary to disable it in some cases though and tou can do that by calling [methodname]#disableWaitForVaadin()# in the
[interfacename]#TestBenchCommands# interface. You can call it in a test case as
follows:

----
testBench(driver).disableWaitForVaadin();
----

When disabled, you can wait for the rendering to finish by calling
[methodname]#waitForVaadin()# explicitly.


----
testBench(driver).waitForVaadin();
----

You can re-enable the waiting with [methodname]#enableWaitForVaadin()# in the
same interface.


[[testbench.special.waituntil]]
== Waiting Until a Condition is Met

In addition to waiting for Vaadin, it is also possible to wait until a condition
is met. This could, for example, be used to wait until an element is visible on
the web page.


----
waitUntil(ExpectedConditions.presenceOfElementLocated(By.xpath("//button[@title='Debug message log']"));
----

The above waits until the specified element is present or times out after
waiting for 10 seconds by default.

`waitUntil(condition, timeout)` allows the timeout duration to be controlled.


[[testbench.special.scrolling]]
== Scrolling
To be able to interact with an element, it needs to be visible on the screen. This limitation is set so that test which are run using a web driver shall simulate a normal user as closely as possible. TestBench handles this automatically by ensuring an element is in view before an interaction is triggered. In some cases you might want to disable this behavior and can then use `TestBenchCommands.setAutoScrollIntoView(false)`.

[[testbench.special.javascript]]
== Executing JavaScript

((("javascript")))
Sometimes the available API does not offer what you are looking for and you want
to execute a JavaScript snippet to accomplish your task. 

TestBench offers some helpers for typical tasks, such as retrieving a property value from an element:
```java
String getPropertyString(String... propertyNames)
Boolean getPropertyBoolean(String... propertyNames)
Integer getPropertyInteger(String... propertyNames)
Double getPropertyDouble(String... propertyNames)
Object getProperty(String... propertyNames)
TestBenchElement getPropertyElement(String... propertyNames)
List<TestBenchElement> getPropertyElements(String... propertyNames)
```

If you need to call a function on an element, you can use `Object callFunction(String methodName, Object... args)`, e.g.
```java
divElement.callFunction("setAttribute", "title", "Hello");
```

[NOTE]
Typically you should use the correct `getPropertyXYZ` depending on the type of the property in JavaScript. If you use another type, the value will be converted using standard JavaScript rules (which may or may not give the result you desire).

When there is no suitable helper available, you can excute any JavaScript snippet using the `executeScript` method available in `TestBenchTestCase` and `TestBenchElement` and add references to elements and other parameters using the `Object... args` parameter. All arguments passed to the
method are available through the `arguments` array in JavaScript.

For example to return the `offsetHeight` property of an element you could do
----
TestBenchElement element = ...; // find the element somehow
Long offsetHeight = (Long)executeScript("return arguments[0].offsetHeight", element);
----

[NOTE]
The `executeScript` call would be the same as using e.g. `element.getPropertyInteger("offsetHeight");`.

The argument array and the return type support a limited set of types:

* HTML elements are converted to `TestBenchElement` instances
* Decimal numbers are converted to `Double`
* Non-decimal numbers are converted to `Integer`
* Booleans are converted to `Boolean`
* All other values except arrays are converted to `String`
* Returned arrays are converted to `List<Object>`, containing types described above

As there is no way to know what type the JavaScript function returns, you always
need to cast the return value.

[[testbench.special.timing]]
== Profiling Test Execution Time

It is not just that it works, but also how long it takes. Profiling test
execution times consistently is not trivial, as a test environment can have
different kinds of latency and interference. For example in a distributed setup,
timings taken on the test server would include the latencies between the test
server, the grid hub, a grid node running the browser, and the web server
running the application. In such a setup, you could also expect interference
between multiple test nodes, which all might make requests to a shared
application server and possibly also share virtual machine resources.

Furthermore, in Vaadin applications, there are two sides which need to be
profiled: the server-side, on which the application logic is executed, and the
client-side, where it is rendered in the browser. Vaadin TestBench includes
methods for measuring execution time both on the server-side and the
client-side.

The [interfacename]#TestBenchCommands# interface offers the following methods
for profiling test execution time:

[methodname]#totalTimeSpentServicingRequests()#:: Returns the total time (in milliseconds) spent servicing requests in the
application on the server-side. The timer starts when you first navigate to the
application and hence start a new session. The time passes only when servicing
requests for the particular session. The timer is shared in the servlet session,
so if you have, for example, multiple portlets in the same application
(session), their execution times will be included in the same total.//TODO
Vaadin 7: windows to
roots

+
Notice that if you are also interested in the client-side performance for the
last request, you must call the [methodname]#timeSpentRenderingLastRequest()#
before calling this method. This is due to the fact that this method makes an
extra server request, which will cause an empty response to be rendered.

[methodname]#timeSpentServicingLastRequest()#:: Returns the time (in milliseconds) spent servicing the last request in the
application on the server-side. Notice that not all user interaction through the
WebDriver cause server requests.

+
As with the total above, if you are also interested in the client-side
performance for the last request, you must call the
[methodname]#timeSpentRenderingLastRequest()# before calling this method.

[methodname]#totalTimeSpentRendering()#:: Returns the total time (in milliseconds) spent rendering the user interface of
the application on the client-side, that is, in the browser. This time only
passes when the browser is rendering after interacting with it through the
WebDriver. The timer is shared in the servlet session, so if you have, for
example, multiple portlets in the same application (session), their execution
times will be included in the same total.

[methodname]#timeSpentRenderingLastRequest()#:: Returns the time (in milliseconds) spent rendering user interface of the
application after the last server request. Notice that not all user interaction
through the WebDriver cause server requests.

+
If you also call the [methodname]#timeSpentServicingLastRequest()# or
[methodname]#totalTimeSpentServicingRequests()#, you should do so before calling
this method. The methods cause a server request, which will zero the rendering
time measured by this method.

The following example is given in the
[filename]#link:https://github.com/vaadin/testbench-demo/blob/master/src/test/java/com/vaadin/testbenchexample/VerifyExecutionTimeITCase.java[VerifyExecutionTimeITCase.java]#
file in the TestBench demo.


----
@Test
public void verifyServerExecutionTime() throws Exception {
    // Get start time on the server-side
    long currentSessionTime = testBench(getDriver())
            .totalTimeSpentServicingRequests();

    // Interact with the application
    calculateOnePlusTwo();

    // Calculate the passed processing time on the serve-side
    long timeSpentByServerForSimpleCalculation =
            testBench().totalTimeSpentServicingRequests() -
            currentSessionTime;

    // Report the timing
    System.out.println("Calculating 1+2 took about "
            + timeSpentByServerForSimpleCalculation
            + "ms in servlets service method.");

    // Fail if the processing time was critically long
    if (timeSpentByServerForSimpleCalculation > 30) {
        fail("Simple calculation shouldn't take " +
             timeSpentByServerForSimpleCalculation + "ms!");
    }

    // Do the same with rendering time
    long totalTimeSpentRendering =
            testBench().totalTimeSpentRendering();
    System.out.println("Rendering UI took "
            + totalTimeSpentRendering + "ms");
    if (totalTimeSpentRendering > 400) {
        fail("Rendering UI shouldn't take "
               + totalTimeSpentRendering + "ms!");
    }

    // A normal assertion on the UI state
    assertEquals("3.0",
        $(TextFieldElement.class).first()
        .getValue());
}
----
